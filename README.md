# [Spark](https://stepik.org/course/115252/syllabus)

[2.1.1 DFs Основы](src/main/scala/DF.scala)
>Создание датафрейма.

[2.1.2 Schema](src/main/scala/Schema.scala)
>Код, выполняющий загрузку данных из файла.\
>Данные в колонках is_delivering_now и has_online_delivery должны в конечном итоге иметь тип IntegerType.\
>В коде предусмотрите возможность наглядной демонстрации выполнения данного условия.

[2.2.1 Read & Write DF](src/main/scala/ReadWrite.scala)
>Создать схему и считать файл.\
>Вывести схему.\
>Сохранить файл в формате parquet.

[2.3.1 Select columns](src/main/scala/Columns.scala)
>Из DF должны быть выбраны  колонки: Hour, TEMPERATURE, HUMIDITY, WIND_SPEED.\
>На экран должны быть выведены первые три строчки данных из выбранных колонок.

[2.3.2 New column, when-otherwise, distinct](src/main/scala/Uniq.scala)
>Создать колонку is_workday, состоящую из значений 0 и 1:\
>[0 - если значением колонки HOLIDAY является Holiday и значением колонки FUNCTIONING_DAY является No].\
>Выведите на экран строчки, которые включают в себя только уникальные значения из колонок  
>"HOLIDAY", "FUNCTIONING_DAY", "is_workday"

[2.3.3 GroupBy, Agg](src/main/scala/MinMax.scala)
>Рассчитывается минимальное и максимальное значение температуры TEMPERATURE для каждой даты Date.\
>Результат расчетов записывается в колонки min_temp, max_temp и выводится на экран.

[2.5.1 Practice 1](src/main/scala/MallCustomers.scala)
>Исправить ошибку в данных (колонка Age). Возраст клиентов был записан неправильно. Вышло так, что все оказались на 2 года младше, чем они есть на самом деле.\
>Разделить клиентов на группы и подсчитать среднее значение Annual Income (k$) для каждой группы:
> * Рассматриваются лица, реальный возраст которых от 30 до 35 лет (включительно).
> * Клиенты делятся на группы в зависимости от пола и возраста.
> * Полученное среднее значение должно быть округлено до 1 знака после запятой.
>
> Записи в датафрейме должны быть отсортированы по полу и возрасту (в порядке возрастания).\
>Создать колонку gender_code, в которую поместить значение 1 (для клиентов мужского пола ) или 0 (для клиентов женского пола).

[2.5.2 Practice 2](src/main/scala/Subtitles.scala)
> Для каждого сезона найти топ-20 самых часто используемых слов (Word и word - это одно и то же слово).\
> Результаты расчетов объединить в общий датафрейм: 
> * w_s1 - колонка, содержащая слова из первого сезона;
> * w_s2 - колонка, содержащая слова из второго сезона;
> * в cnt_s1 и cnt_s2  - данные о том, сколько раз слово встретилось в субтитрах для первого (cnt_s1) и второго сезона (cnt_s2);
> * колонка id  содержит числа от 0 до 19 включительно.

[3.2.1 Null](src/main/scala/AthleticShoes.scala)
> Конвертировать DF в DS с условиями:
> * строки,  в которых отсутствует значение item_name или item_category  - следует удалить
> * если значение item_after_discount отсутствует, на его место следует записать значение, находящееся в колонке item_price
> * если отсутствует значение item_rating, следует использовать 0
> * если не указан buyer_gender, запишите в качестве значения unknown
> * если для percentage_solds не указано значение, используйте -1
> * если пропущено любое другое значение, вместо него используйте n/a

[3.3.1 Datasets vs Dataframe](src/main/scala/AiJobsIndustry.scala)
> Исследовать данные об отзывах. \
> Подсчитайте:
> * общее количество отзывов, полученное каждой компанией (Company)
> * общее количество отзывов для каждой должности (JobTitle) 
> * stats_type - служит для уточнения, чьи именно данные предоставляются - company или job
> * count_type - укажите тип подсчитанного значения - max или min 
>
> И для компании,  и для должности определите лидера, для которого укажите локацию Location с минимальным и максимальным числом отзывов. 
>
> Задача должна быть решена:
> * сначала с использованием датафреймов
> * затем к тому же результату нужно прийти,  но уже с использованием датасетов

[3.4.1 Datasets](src/main/scala/Cars.scala)
> Получить датасет, включающий в себя все изначально имеющиеся колонки, к которым добавится колонка 
> * avg_mileage: в колонке во всех строчках будет записано одно и то же число - средний пробег всех имеющихся машин. \
Если у какой-либо машины не указан пробег, считайте, что он равен 0.
> * years_since_purchase: колонка хранит информацию о том, сколько полных лет прошло со дня покупки. \
Значение должно быть рассчитано для каждой машины

[3.4.2 Datasets](src/main/scala/HrDataset.scala)
> Реализовать сервис для предоставления информации о номере должности (positionID) в ответ на поступивший по API запрос. 
> В запросе содержится список из наименований должностей (position), названия могут быть неполные, 
> т.е. могут включать в себя только первое слово из полного названия должности.
> При решении задачи для удобства  считайте, что запрос представляет из себя список. Например, List("BI", "it")

[4.2.1 RDD](src/main/scala/Avocado.scala)
> Работайте только с RDD, никаких датафреймов и датасетов:
> * подсчитайте количество уникальных регионов (region), для которых представлена статистика
> * выберите и отобразите на экране все записи о продажах авокадо, сделанные после 2018-02-11
> * найдите месяц, который чаще всего представлен в статистике
> * найдите максимальное и минимальное значение avgPrice
> * отобразите средний объем продаж (volume) для каждого региона (region)

[4.3.1 RDD](src/main/scala/Logs.scala)
> * 1. отобразить статистику по успешно считанным строчкам и неуспешно - 
> для этого достаточно посчитать количество строк для каждого случая.
> * 2. найти количество записей для каждого кода ответа (response)
> * 3. следует собрать статистику по размеру ответа (bytes): сколько всего байт было отправлено \
> (сумма всех значений), среднее значение, максимальное и минимальное значение.
> * 4. подсчитать количество уникальных хостов (host), для которых представлена статистика
> * 5. найти топ-3 наиболее часто встречающихся хостов (host). Результат анализа, выводимый на экран, должен включать в \
> себя хоста и подсчитанную частоту встречаемости этого хоста.
> * 6. определите дни недели (понедельник, вторник и тд), когда чаще всего выдавался ответ (response) 404.  \
> В статистике отобразите день недели (в каком виде отображать день остается на ваше усмотрение, например, Mon, Tue ) \
> и сколько раз был получен ответ 404. Достаточно отобразить топ-3 дней.

[4.3.2 RDD](src/main/scala/Amazon.scala)
> Считать данные из json файла без использования DataFrame или Dataset. Работайте только с RDD. \
> Содержимое файла должно быть конвертировано в case классы и выведено на экран посредством обычного принта.